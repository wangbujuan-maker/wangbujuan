% 设置地图尺寸
GridLength = 30;
GridWidth = 30;

% 定义地图（1表示起始位置，2表示自由空间，-1表示障碍物）
MAP=[1,2,2,2,2,2,2,2,-1,-1,2,2,2,2,2,-1,2,2,2,2,2,2,2,2,2,-1,2,-1,2,2;
2,2,2,2,2,2,2,-1,2,2,-1,2,2,2,2,2,2,2,2,2,2,2,2,2,-1,-1,-1,2,2,2;
2,2,2,2,2,2,2,2,2,2,-1,2,2,-1,2,2,2,2,-1,2,-1,2,2,2,2,-1,2,2,2,2;
2,2,-1,-1,2,2,2,2,2,2,2,2,2,2,2,-1,2,-1,2,2,2,2,2,2,2,2,-1,2,-1,2;
2,2,-1,-1,2,2,2,2,2,2,2,-1,2,2,2,2,-1,2,2,2,-1,2,2,2,2,2,2,2,2,2;%5
2,2,2,2,2,2,2,2,2,2,2,-1,2,2,2,-1,2,2,2,2,2,-1,2,2,2,2,-1,2,2,-1;
2,2,2,2,2,2,2,2,2,2,2,2,2,2,-1,-1,-1,-1,-1,-1,2,-1,2,2,2,2,2,-1,-1,2;
2,2,2,2,2,2,2,2,2,2,2,2,2,2,-1,2,2,2,2,2,-1,-1,2,2,2,2,2,2,2,-1;
2,-1,2,2,2,2,2,2,2,2,2,2,2,2,2,-1,2,2,2,2,2,2,2,2,-1,-1,2,-1,-1,2;
2,2,2,2,-1,-1,2,-1,-1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2;%10
-1,2,2,2,2,2,2,2,2,2,2,-1,2,2,2,-1,-1,-1,2,2,2,2,2,2,-1,2,2,2,2,2;
2,2,2,2,2,2,-1,2,2,2,2,-1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,-1,2,2;
2,2,2,-1,-1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,-1,2,-1,2,2,2,2,-1,2,2,2;
2,2,2,2,2,-1,2,2,2,2,2,2,2,2,-1,2,-1,2,2,2,-1,-1,2,2,2,2,2,2,2,2;
2,2,2,2,2,2,2,2,2,2,2,2,2,2,-1,2,2,-1,2,2,2,2,2,2,2,2,2,2,2,1;%15
2,2,-1,-1,2,-1,2,2,2,2,2,-1,2,2,2,2,2,2,2,-1,2,2,2,2,-1,2,2,2,2,-1;
-1,-1,2,2,2,2,2,2,2,2,2,2,-1,2,2,2,2,2,2,2,2,-1,2,2,2,-1,-1,2,2,2;
-1,2,2,2,2,2,-1,-1,-1,-1,2,2,2,2,2,-1,2,-1,2,-1,-1,-1,-1,-1,2,2,2,2,-1,2;
2,2,2,2,2,-1,2,2,2,-1,2,2,2,-1,-1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2;
2,2,2,2,2,2,2,2,2,2,-1,-1,2,-1,2,2,2,2,2,2,2,2,2,-1,2,-1,2,2,2,2;
2,2,2,2,-1,2,2,2,2,-1,2,2,2,2,2,2,2,-1,2,2,2,-1,2,2,2,2,2,2,-1,2;
2,2,2,2,2,2,2,2,-1,2,-1,2,2,-1,2,2,-1,2,2,2,2,2,-1,2,2,2,-1,2,2,2;
2,2,-1,2,-1,2,2,-1,2,2,2,2,2,2,2,2,-1,2,2,-1,2,2,2,2,-1,2,2,2,2,2;
2,2,2,-1,2,2,2,2,-1,-1,2,-1,2,2,2,2,2,2,2,2,2,2,2,-1,2,2,2,2,2,-1;
2,-1,2,2,-1,2,2,2,2,-1,-1,2,-1,2,2,2,-1,-1,2,2,-1,2,2,2,-1,-1,2,2,2,2;
2,-1,2,-1,2,2,2,-1,-1,2,2,2,-1,2,2,2,2,2,2,2,-1,2,2,-1,2,2,2,2,-1,-1;
2,-1,-1,2,2,-1,-1,2,2,2,-1,2,2,2,2,2,2,2,2,2,2,-1,-1,2,-1,2,2,2,2,2;
2,2,-1,2,2,2,2,2,2,2,2,2,2,-1,2,2,2,2,2,2,2,2,2,2,2,2,2,-1,2,2;
-1,-1,-1,2,2,2,2,-1,2,-1,2,2,2,2,2,2,2,2,-1,2,2,-1,2,2,2,2,-1,2,2,2;
1,2,2,2,2,2,2,2,2,2,-1,2,2,2,-1,2,2,2,-1,2,2,2,2,2,-1,2,-1,2,2,2
];
% 初始化图结构
G = graph();

% 遍历MAP，创建节点和边
for i = 1:GridLength
    for j = 1:GridWidth
        if MAP(i, j) ~= -1
            % 当前节点的标签
            node = sub2ind([GridLength, GridWidth], i, j);
            G = addnode(G, num2str(node));
            
            % 添加与邻居的边
            if i > 1 && MAP(i-1, j) ~= -1
                neighbor = sub2ind([GridLength, GridWidth], i-1, j);
                G = addedge(G, num2str(node), num2str(neighbor), 1);
            end
            if j > 1 && MAP(i, j-1) ~= -1
                neighbor = sub2ind([GridLength, GridWidth], i, j-1);
                G = addedge(G, num2str(node), num2str(neighbor), 1);
            end
        end
    end
end
% 计算最小生成树
T = minspantree(G);

% 可视化最小生成树
figure;
plot(T);
title('Minimum Spanning Tree of the MAP');


% 假设有3个机器人
num_robots = 3;
robot_paths = cell(1, num_robots);

% 起始位置索引
start_positions = [1, 1; 30, 1; 15, 30];

% 初始化机器人路径
for r = 1:num_robots
   start_node = sub2ind([GridLength, GridWidth], start_positions(r, 1), start_positions(r, 2));
    
    % 初始化机器人路径
    robot_paths{r} = {};
    
    % 找到生成树上的所有节点
    all_nodes = table2array(T.Nodes);
    
    % 遍历生成树上的所有节点，计算最短路径
    for i = 1:numel(all_nodes)
        target_node = all_nodes{i};
        % 计算从起始节点到目标节点的最短路径
        [~, ~, path] = shortestpath(T, num2str(start_node), target_node);
        robot_paths{r} = [robot_paths{r}, path]; % 使用逗号连接单元格数组
    end
end

% 机器人移动和覆盖模拟
env = MAP;
figure; % 新建一个图形窗口
hold on; % 保持图形窗口

% 记录上一个位置
prev_positions = cell(1, num_robots);
for r = 1:num_robots
    prev_positions{r} = [];
end

for r = 1:num_robots
    for k = 1:length(robot_paths{r})
        node = robot_paths{r}(k);
        
        if isnan(node) || node <= 0
            continue;
        end
        
        [x, y] = ind2sub([GridLength, GridWidth], node);
        
        if x <= 0 || y <= 0 || x > GridLength || y > GridWidth
            continue;
        end
        
        % 标记为已覆盖
        if env(x, y) == 2
            env(x, y) = r + 2;
        end
        
        % 清空当前图形窗口
        clf;
        % 绘制当前覆盖状态
        imagesc(env);
        title(['Robot ', num2str(r), ' Coverage']);
        hold on;
        
        % 绘制直线
        if ~isempty(prev_positions{r})
            prev_x = prev_positions{r}(2); % 之前位置的 x 坐标
            prev_y = prev_positions{r}(1); % 之前位置的 y 坐标
            plot([prev_y, y], [prev_x, x], 'k-', 'LineWidth', 2); % 绘制直线
        end
        
        % 更新当前位置
        prev_positions{r} = [y, x];
        
        % 刷新图形窗口
        drawnow;
        
        % 显示覆盖情况
        pause(0.5); % 暂时增加暂停时间以便观察效果
    end
end

% 显示最终覆盖结果
clf;
imagesc(env);
title('Final Coverage Map');
hold off;
